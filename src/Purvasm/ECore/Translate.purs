-- | translating CoreFn generated by purs compiler ECF.
-- | Large part of this module is triival translating functions.
module Purvasm.ECore.Translate where

import Prelude

import Control.Monad.ST as ST
import Control.Monad.ST.Internal as STRef
import Data.Array (foldl, foldr)
import Data.Array as Array
import Data.Array.ST as STArray
import Data.List ((:))
import Data.List as L
import Data.Maybe (Maybe(..))
import Data.String (joinWith)
import Data.String as Str
import Data.String.Regex as Re
import Data.String.Regex.Flags (unicode)
import Data.String.Regex.Unsafe (unsafeRegex)
import Data.Traversable (traverse)
import Data.Tuple (Tuple(..))
import Data.Tuple.Nested (type (/\), (/\))
import Effect.Console (logShow)
import Effect.Unsafe (unsafePerformEffect)
import Partial.Unsafe (unsafeCrashWith)
import PureScript.CoreFn as CF
import PureScript.CoreFn.Analyser as Analyser
import PureScript.CoreFn.Utils (typeClassConstructorRegex)
import Purvasm.ECore.Syntax (Ann, AtomicLiteral(..), Binding(..), CaseAlternative(..), Expr(..), Literal(..), Module(..), Pattern(..), Prop(..), StructuredLiteral(..), emptyAnn)
import Purvasm.ECore.Transform (unsafeSubstitute)
import Purvasm.Global (GlobalEnv, GlobalName, lookupConstructor, lookupTypeclass, mkGlobalName)
import Purvasm.Global as Global
import Purvasm.Types (Ident(..), ModuleName(..))
import Safe.Coerce (coerce)

type CorefnExpr = CF.Expr CF.Ann

type TranslEnv =
  { moduleName :: ModuleName
  , global :: GlobalEnv
  }

translateCoreFn :: GlobalEnv -> CF.Module CF.Ann -> Module Ann
translateCoreFn genv (CF.Module cfModule) = do
  let
    decls = loop [] [] cfModule.decls
  Module
    { name: coerce cfModule.name
    , decls
    }
  where
  tenv =
    { global: genv
    , moduleName: coerce cfModule.name
    }
  loop decls stillToTransl = Array.uncons >>> case _ of
    Nothing
      | [] <- stillToTransl -> decls
      | otherwise -> loop decls [] stillToTransl
    Just { head, tail } ->
      let
        expr /\ added = translDecl head
      in
        loop (expr `Array.cons` decls) (added <> stillToTransl) tail

  translDecl :: CF.Bind CF.Ann -> (Binding Ann /\ Array (CF.Bind CF.Ann))
  translDecl = case _ of
    CF.NonRec (CF.Binding a (CF.Ident ident) expr)
      -- Typeclass constructor is not needed to be contained in compiled module,
      -- so we omit it by returning ExprNone construction.
      | CF.Ann { meta: Just CF.IsTypeClassConstructor } <- a
      , Re.test typeClassConstructorRegex ident ->
          Binding (coerce ident) ExprNone /\ []
      -- Typeclass instance. We promoto each method implementation function 
      -- from record property to toplevel phrase.
      -- | Just typeclassInst <- Analyser.typeclassInstanceOfExpr expr -> do
      --     let
      --       methods = typeclassInst.members <#>
      --         \((CF.Ident method) /\ impl) -> CF.NonRec $
      --           CF.Binding CF.emptyAnn (CF.Ident $ ident <> "$" <> method) impl
      --       methodRefs = typeclassInst.members <#>
      --         \((CF.Ident method) /\ _) 
      --           -- we trap the case memebr identifier is like constraining typeclass name. 
      --           -- | Re.test (unsafeRegex """^[A-Z]""" unicode) method  
      --           | otherwise -> do
      --       instance_ = CF.ExprLit CF.emptyAnn $
      --         CF.LitRecord methodRefs
      --         _ = unsafePerformEffect (logShow methods)
      --     Binding (coerce ident) ExprNone /\ methods
      | otherwise ->
          (Binding (coerce ident) (translateExpr tenv (Ident ident) emptyAnn expr)) /\ []
    -- recursive binding groups is translated into single `let rec` construction,
    -- and each toplevel phrase in original CoreFn module is translated into 
    -- accessor to the grouped expression.
    -- For e.g.
    -- ```purs
    -- odd :: Int -> Boolean
    -- odd n = even (n - 1)
    --
    -- even :: Int -> Boolean
    -- even n = odd (n - 1)
    -- ```
    -- is translated into things such as:
    -- ```
    -- odd_even_RecBindGrp = 
    --   let
    --     odd n = even (n - 1)
    --     even n = odd (n - 1)
    --   in 
    --     { even, odd }
    -- odd = odd_even_RecBindGrp.odd
    -- even = odd_even_RecBindGrp.even
    -- ``` 
    CF.Rec bindings ->
      let
        idents = (coerce <<< CF.bindingIdent) <$> bindings
        bindGrpIdent = Ident $ "$pvsm_RecBindGrp__" <> (joinWith "_" idents)
        bindGrpMembers = bindings <#> \(CF.Binding _ ident _) ->
          let
            expr = CF.ExprAccessor
              CF.emptyAnn
              (mkRecursBindGroupVar bindGrpIdent (coerce idents))
              (coerce ident)
          in
            CF.NonRec (CF.Binding CF.emptyAnn ident expr)

        bindGrpExpr = CF.ExprLet
          CF.emptyAnn
          [ CF.Rec bindings ]
          (mkBindGrpRecord $ coerce idents)

        recGrpExp = translateExpr tenv bindGrpIdent emptyAnn bindGrpExpr

        -- rename all recursive binding group members' identifier
        -- with unquyalified one.
        renameRecMembers = flip
          (foldr (\ident -> unsafeSubstitute (Ident ident) ExprNone))
          idents
      in
        Binding bindGrpIdent (renameRecMembers recGrpExp) /\ bindGrpMembers

  mkRecursBindGroupVar ident members =
    let
      varAnn = CF.Ann { meta: Just $ CF.IsRecursBindGrp members }
    in
      CF.ExprVar
        varAnn
        (CF.Qualified (Just cfModule.name) (coerce ident))

  mkBindGrpRecord idents =
    CF.ExprLit
      (CF.Ann { meta: Just $ CF.IsRecursBindGrp idents })
      ( CF.LitRecord
          ( idents <#> \id ->
              CF.Prop (coerce id) (CF.ExprVar CF.emptyAnn (CF.Qualified Nothing (CF.Ident $ coerce id)))
          )
      )

translateExpr :: TranslEnv -> Ident -> Ann -> CorefnExpr -> Expr Ann
translateExpr { moduleName, global } ident = transl
  where
  transl ann = case _ of
    exprLit@(CF.ExprLit _ lit)
      | Just constLit <- exprConstantLiteral exprLit -> ExprLit ann constLit
      | otherwise -> case lit of
          CF.LitArray lits -> ExprArray ann (transl ann <$> lits)
          CF.LitRecord props -> ExprRecord ann $
            (\(CF.Prop prop a) -> Prop prop $ transl ann a) <$> props
          _ -> unsafeCrashWith "translateExpr: Literal in ExprArray"
    CF.ExprVar _ var -> translExprVar ann var
    CF.ExprAccessor _ expr prop -> ExprAccess ann (transl ann expr) prop
    CF.ExprUpdate _ expr updates -> ExprUpdate ann (transl ann expr) $
      map (\(CF.Prop p e) -> p /\ transl ann e) updates

    CF.ExprAbs _ arg body -> translExprAbs ann (L.singleton arg) body
    CF.ExprApp _ func arg
      | CF.ExprVar (CF.Ann { meta: Just CF.IsNewtype }) _ <- func -> transl ann arg
      | otherwise -> translExprApp ann [ arg ] func
    CF.ExprLet _ binds body -> translExprLet ann binds body
    CF.ExprConstructor _ typ (CF.Ident ctor) args
      | ctor' <- Str.replace (Str.Pattern "$Dict") (Str.Replacement "") $ coerce ident
      , globalName' <- mkGlobalName moduleName (Ident ctor')
      , Just x <- lookupTypeclass globalName' global -> unsafeCrashWith "FO!"
      | otherwise -> translConstructor ann typ (coerce ctor) args
    -- We trap the special case: the case destructuring against typeclass constructor:
    CF.ExprCase _ [ _ ] [ caseAlt ]
      | CF.CaseAlternative [ binder ] act <- caseAlt
      , CF.BinderConstructor (CF.Ann { meta: Just CF.IsNewtype }) _ ctor [ arg ] <- binder
      , CF.BinderVar _ var <- arg
      , Just (Global.ValTypeclass clsName) <-
          Global.globalNameOfQualifiedVar ctor
            >>= flip Global.lookupValue global
      , Just typeclass <- Global.lookupTypeclass clsName global
      , CF.Unconditional actExp <- act -> do
          let
            substDict = unsafeSubstitute (coerce var) (ExprTypeclassInstance ann clsName Nothing)
          substDict $ transl ann actExp
    CF.ExprCase _ caseExprs caseAlts -> translExprCase ann caseExprs caseAlts
  translExprVar ann (CF.Qualified qual (CF.Ident ident')) = case qual of
    Just (CF.ModuleName modname) ->
      let
        gloname = mkGlobalName (ModuleName modname) (Ident ident')
      in
        ExprGlobal ann gloname
    _ -> ExprVar ann (Ident ident')

  translExprAbs ann args = case _ of
    CF.ExprAbs _ arg body -> translExprAbs ann (arg : args) body
    expr -> do
      let
        argIdents = coerce $ L.foldl (flip Array.cons) [] args
      ExprAbs ann argIdents (transl ann expr)

  translExprApp ann args = case _ of
    CF.ExprApp _ f arg -> translExprApp ann (Array.cons arg args) f
    expr
      | CF.ExprVar _ (CF.Qualified (Just (CF.ModuleName mn)) (CF.Ident id)) <- expr
      , Just desc <- Global.lookupConstructor (mkGlobalName (coerce mn) (coerce id)) global
      , desc.arity == Array.length args ->
          let
            ctorArgs = transl ann <$> args
          in
            ExprConstruct emptyAnn desc ctorArgs
      | otherwise -> ExprApp emptyAnn (transl ann expr) (transl ann <$> args)

  translConstructor ann _ ctor args =
    let
      ctorName = mkGlobalName moduleName ctor
    in
      case Global.lookupConstructor ctorName global of
        Nothing -> unsafeCrashWith $ "translConstructor: Unknown constructor " <> show ctor
        Just desc
          | desc.arity == 0 -> ExprNone
          | otherwise ->
              let
                ctorVar = CF.ExprVar CF.emptyAnn (CF.Qualified (Just $ coerce moduleName) (coerce ctor))
                applyCtorArg term arg =
                  CF.ExprApp CF.emptyAnn term (CF.ExprVar CF.emptyAnn (CF.Qualified Nothing (coerce arg)))
                ctorVal = foldl applyCtorArg ctorVar args

              in
                transl ann (foldr (\arg term -> CF.ExprAbs CF.emptyAnn (coerce arg) term) ctorVal args)

  translExprLet ann binds expr = case spanMap CF.nonRecBinding binds of
    [] /\ rest
      | Just { head: CF.Rec bindGrp, tail } <- Array.uncons rest ->
          let
            body =
              if (Array.null tail) then expr
              else CF.ExprLet CF.emptyAnn tail expr
            trBinds = translLetBind ann <$> bindGrp
          in
            ExprLetRec ann trBinds (transl ann body)
    nonRecs /\ rest ->
      let
        body =
          if (Array.null rest) then expr
          else CF.ExprLet CF.emptyAnn rest expr
        trBinds = translLetBind ann <$> nonRecs
      in
        ExprLet ann trBinds (transl ann body)
    where
    translLetBind ann' (CF.Binding _ id b) = Tuple (coerce id) (transl ann b)

  translExprCase ann caseExprs caseAlts =
    ExprCase
      emptyAnn
      (transl ann <$> caseExprs)
      (translCaseAlternative ann <$> caseAlts)

  translCaseAlternative ann (CF.CaseAlternative binders caseGuard) =
    let
      patterns = translCaseBinder <$> binders
      action = translCaseGuard ann caseGuard
    in
      CaseAlternative { patterns, action }

  translCaseBinder :: CF.Binder CF.Ann -> Pattern
  translCaseBinder = case _ of
    CF.BinderNull _ -> PatWildcard
    CF.BinderVar _ var -> PatVar (coerce var)
    CF.BinderLit _ lit
      | Just atomLit <- binderLiteral lit -> PatLiteral atomLit
      | otherwise -> case lit of
          CF.LitArray binders -> PatArray (translCaseBinder <$> binders)
          CF.LitRecord props -> PatRecord (map (map translCaseBinder <<< translProp) props)
          _ -> unsafeCrashWith "translCaseBinder: Impossible!"
    CF.BinderConstructor a _ ctor binders
      | CF.Ann { meta: Just CF.IsNewtype } <- a
      , Just binder <- Array.head binders -> translCaseBinder binder
      | CF.Qualified (Just (CF.ModuleName mn)) (CF.Ident ident') <- ctor
      , ctorName <- mkGlobalName (ModuleName mn) (Ident ident')
      , Just desc <- lookupConstructor ctorName global ->
          PatConstruct desc (translCaseBinder <$> binders)
      | otherwise -> unsafeCrashWith $ "Unknown constructor: " <> show ctor
    CF.BinderNamed _ ident' binder -> PatAliase (coerce ident') (translCaseBinder binder)

  translCaseGuard ann = case _ of
    CF.Unconditional expr -> transl ann expr
    -- We desugar guard case to nested if-then-else. 
    CF.Guarded guards ->
      let
        addIf (CF.Guard cond expr) = ExprIf ann (transl ann cond) (transl ann expr)
      in
        foldr addIf (ExprStaticFail ann) guards

  -- _ -> unsafeCrashWith "translCaseBinder: Impossible!"

  binderLiteral :: CF.Literal (CF.Binder _) -> Maybe AtomicLiteral
  binderLiteral = case _ of
    CF.LitInt i -> Just $ LitInt i
    CF.LitBoolean b -> Just $ LitBoolean b
    CF.LitChar c -> Just $ LitChar c
    CF.LitNumber n -> Just $ LitNumber n
    CF.LitString s -> Just $ LitString s
    _ -> Nothing

-- CF.LitArray lits -> ExprLit unit $ LitStruct (LitArray $ map translateExpr lits)

globalNameOfExprVar :: forall a. CF.Expr a -> Maybe GlobalName
globalNameOfExprVar = case _ of
  CF.ExprVar _ (CF.Qualified (Just (CF.ModuleName mn)) (CF.Ident id)) ->
    Just $ mkGlobalName (coerce mn) (coerce id)
  _ -> Nothing

exprConstantLiteral :: CF.Expr CF.Ann -> Maybe Literal
exprConstantLiteral = case _ of
  CF.ExprLit _ lit -> case lit of
    CF.LitInt i -> Just (LitAtomic (LitInt i))
    CF.LitChar c -> Just (LitAtomic (LitChar c))
    CF.LitBoolean b -> Just (LitAtomic (LitBoolean b))
    CF.LitNumber n -> Just (LitAtomic (LitNumber n))
    CF.LitString s -> Just (LitAtomic (LitString s))
    CF.LitArray lits -> LitStruct <<< LitArray <$> traverse exprConstantLiteral lits
    CF.LitRecord props -> LitStruct <<< LitRecord <$> traverse (traverse exprConstantLiteral <<< translProp) props
  _ -> Nothing

translModuleName :: CF.ModuleName -> ModuleName
translModuleName = coerce

translProp :: CF.Prop ~> Prop
translProp (CF.Prop k v) = Prop k v

translIdent :: CF.Ident -> Ident
translIdent = coerce

spanMap :: forall a b. (a -> Maybe b) -> Array a -> Array b /\ Array a
spanMap pred xs = ST.run do
  init <- STArray.new
  rest <- STArray.thaw xs
  continue <- STRef.new true
  ST.while (STRef.read continue) do
    STArray.shift rest >>= case _ of
      Nothing -> STRef.write false continue $> unit
      Just r
        | Just b <- pred r -> STArray.push b init $> unit
        | otherwise -> STArray.unshift r rest *> STRef.write false continue $> unit
  (/\) <$> STArray.freeze init <*> STArray.freeze rest