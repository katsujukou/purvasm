-- | translating CoreFn generated by purs compiler ECF.
-- | Large part of this module is triival translating functions.
module Purvasm.ECore.Translate where

import Prelude

import Control.Monad.ST as ST
import Control.Monad.ST.Internal as STRef
import Data.Array (foldl, foldr, mapWithIndex)
import Data.Array as Array
import Data.Array.ST as STArray
import Data.List ((:))
import Data.List as L
import Data.Maybe (Maybe(..))
import Data.String as Str
import Data.Traversable (traverse)
import Data.Tuple (Tuple(..), fst)
import Data.Tuple.Nested (type (/\), (/\))
import Partial.Unsafe (unsafeCrashWith)
import PureScript.CoreFn as CF
import Purvasm.Global.SpecialGlobal (glo_Prim_undefined)
import Purvasm.ECore.Syntax (Ann(..), Binding(..), CaseAlternative(..), Context(..), Expr(..), Literal(..), Meta(..), Module(..), Pattern(..), Prop(..), StructuredLiteral(..), addContext, emptyAnn, exprAnn, setMeta)
import Purvasm.Global (GlobalEnv, GlobalName, ValueDesc(..), globalNameOfQualifiedVar, identOfGlobalName, lookupConstructor, lookupTypeclass, mkGlobalName)
import Purvasm.Global as Global
import Purvasm.Types (AtomicConstant(..), Ident(..), ModuleName(..), toIdent)
import Safe.Coerce (coerce)

type CorefnExpr = CF.Expr CF.Ann

type TranslEnv =
  { moduleName :: ModuleName
  , global :: GlobalEnv
  }

translateCoreFn :: GlobalEnv -> CF.Module CF.Ann -> Module Ann
translateCoreFn genv (CF.Module cfModule) = do
  let
    decls = loop [] [] cfModule.decls
  Module
    { name: coerce cfModule.name
    , decls
    }
  where
  tenv =
    { global: genv
    , moduleName: coerce cfModule.name
    }
  loop decls stillToTransl = Array.uncons >>> case _ of
    Nothing
      | [] <- stillToTransl -> decls
      | otherwise -> loop decls [] stillToTransl
    Just { head, tail } ->
      let
        expr /\ added = translDecl head
      in
        loop (expr `Array.cons` decls) (added <> stillToTransl) tail

  translDecl :: CF.Bind CF.Ann -> (Binding Ann /\ Array (CF.Bind CF.Ann))
  translDecl = case _ of
    CF.NonRec binding -> translDeclBind binding
    CF.Rec bindings -> case Array.uncons bindings of
      Nothing -> unsafeCrashWith "translDecl: Impossible!"
      Just { head, tail } ->
        let
          trBinding /\ rest = translDeclBind head
        in
          trBinding /\ if Array.null tail then rest else [ CF.Rec tail ] <> rest

  translDeclBind :: CF.Binding CF.Ann -> (Binding Ann) /\ (Array (CF.Bind CF.Ann))
  translDeclBind = case _ of
    CF.Binding a (CF.Ident ident) expr
      -- Typeclass declaration.
      | CF.Ann { meta: Just CF.IsTypeClassConstructor } <- a
      , typeclassCtorName <- mkGlobalName (tenv.moduleName) (Ident ident)
      , Just { desc: ValTypeclass typeclassName } <- Global.lookupValue typeclassCtorName tenv.global
      , Just { members } <- Global.lookupTypeclass typeclassName tenv.global ->
          Binding (identOfGlobalName typeclassName) (ExprTypeclass emptyAnn members) /\ []
      | otherwise ->
          let
            ident' = coerce ident
            ann = emptyAnn # addContext (ToplevelPhrase $ mkGlobalName tenv.moduleName ident')
          in
            (Binding ident' (translateExpr tenv (Ident ident) ann expr)) /\ []

translateExpr :: TranslEnv -> Ident -> Ann -> CorefnExpr -> Expr Ann
translateExpr { moduleName, global } ident = transl
  where
  transl ann = case _ of
    exprLit@(CF.ExprLit _ lit)
      | Just constLit <- exprConstantLiteral global exprLit -> ExprLit ann constLit
      | otherwise -> case lit of
          CF.LitArray lits -> ExprArray ann (transl ann <$> lits)
          CF.LitRecord props
            | Ann { context: TypeClassCtorArg cls : _ } <- ann -> do
                case Global.lookupTypeclass cls global of
                  Nothing -> unsafeCrashWith $ "Unknown typeclass: " <> show cls
                  Just { members } -> do
                    let
                      ann' = addContext (TypeclassInstanceDecl cls) ann
                    ExprTypeclassInstance ann' cls $
                      ( members
                          <#>
                            ( \(member /\ _) -> case Array.find (CF.propKey >>> coerce >>> (_ == member)) props of
                                Nothing -> unsafeCrashWith $ "Typeclass member " <> show member <> " is missing!"
                                Just (CF.Prop _ impl) ->
                                  transl (addContext (TypeclassMemberImpl member) ann') impl
                            )

                      )
            | otherwise -> do
                let
                  trProps = props <#> \(CF.Prop p exp) ->
                    Prop p (transl (addContext (RecordProp p) ann) exp)
                ExprRecord ann trProps
          _ -> unsafeCrashWith "translateExpr: Literal in ExprArray is impossible!"
    CF.ExprVar _ var -> translExprVar ann var
    CF.ExprAccessor _ expr prop ->
      let
        trExp = transl ann expr
        trAnn = exprAnn trExp
      in
        case trAnn of
          Ann { meta: Just (IsTypeclassDict clsname) }
            | Just typeclass <- Global.lookupTypeclass clsname global
            , Just (_ /\ mbConstraint) <- Array.find (fst >>> (_ == Ident prop)) typeclass.members
            , Just constraint <- mbConstraint ->
                let
                  ann' = setMeta (IsTypeclassDict constraint) ann
                in
                  ExprAccess ann' trExp prop
          _ -> ExprAccess ann trExp prop
    CF.ExprUpdate _ expr updates -> ExprUpdate ann (transl (addContext RecordUpdateExpr ann) expr) $
      map (\(CF.Prop p e) -> p /\ transl (addContext (RecordUpdateUpdator p) ann) e) updates

    CF.ExprAbs _ arg body -> translExprAbs ann (L.singleton arg) body

    CF.ExprApp _ func arg
      | CF.ExprVar varAnn varName <- func
      , CF.Ann { meta: Just CF.IsNewtype } <- varAnn ->
          case globalNameOfQualifiedVar varName of
            Nothing -> unsafeCrashWith "translExpr: unqualified newtype constructor is impossible!"
            Just ctorName
              | Just val <- Global.lookupValue ctorName global
              , { desc: ValTypeclass clsName } <- val ->
                  transl (addContext (TypeClassCtorArg clsName) ann) arg
              | otherwise -> transl ann arg
      | otherwise ->
          translExprApp ann [ arg ] func

    CF.ExprLet _ binds body -> translExprLet ann binds body
    CF.ExprConstructor _ typ (CF.Ident ctor) args
      | ctor' <- Str.replace (Str.Pattern "$Dict") (Str.Replacement "") $ coerce ident
      , globalName' <- mkGlobalName moduleName (Ident ctor')
      , Just x <- lookupTypeclass globalName' global -> unsafeCrashWith "FO!"
      | otherwise -> translConstructor ann typ (coerce ctor) args
    -- We trap the special case: the case destructuring against 
    -- typeclass constructor:
    CF.ExprCase _ [ caseHead ] [ caseAlt ]
      | CF.ExprVar _ (CF.Qualified _ headVar) <- caseHead
      , CF.CaseAlternative [ binder ] act <- caseAlt
      , CF.Unconditional actExpr <- act
      , CF.BinderConstructor (CF.Ann { meta: Just CF.IsNewtype }) _ ctor [ arg ] <- binder
      , CF.BinderVar _ var <- arg
      , Just { desc: Global.ValTypeclass clsName } <-
          Global.globalNameOfQualifiedVar ctor
            >>= flip Global.lookupValue global
      , Just typeclass <- Global.lookupTypeclass clsName global ->
          let
            casHeadAnn = ann # addContext CaseHead # setMeta (IsTypeclassDict clsName)
            casActAnn = ann # addContext CaseAction
          in
            ExprCase ann
              [ ExprVar casHeadAnn (coerce headVar) ]
              [ CaseAlternative
                  { patterns: [ PatVar (coerce var) ]
                  , action: transl casActAnn actExpr
                  }
              ]
    -- Translating case expression.
    CF.ExprCase _ caseExprs caseAlts -> translExprCase ann caseExprs caseAlts

  translExprVar ann qual@(CF.Qualified _ ident') = case globalNameOfQualifiedVar qual of
    Just gloname
      | gloname == glo_Prim_undefined ->
          ExprNil ann
      | otherwise ->
          let
            ann' = case Global.lookupValue gloname global of
              Just { desc: ValTypeclassInstance clsname } -> setMeta (IsTypeclassDict clsname) ann
              _ -> ann
          in
            ExprGlobal ann' gloname
    Nothing ->
      ExprVar ann (toIdent ident')

  translExprAbs ann args = go args
    where
    go args' = case _ of
      CF.ExprAbs _ arg body -> go (arg : args') body
      expr -> do
        let
          argIdents = coerce $ L.foldl (flip Array.cons) [] args'
        ExprAbs ann argIdents (transl ann expr)

  translExprApp ann = go
    where
    go args = case _ of
      CF.ExprApp _ f arg -> translExprApp ann (Array.cons arg args) f
      CF.ExprVar _ varName
        | Just gloname <- globalNameOfQualifiedVar varName
        , Just desc <- Global.lookupConstructor gloname global
        , desc.arity == Array.length args ->
            let
              mkAnn :: Int -> Ann -> Ann
              mkAnn = addContext <<< CtorArg gloname
              ctorArgs = mapWithIndex (\i arg -> transl (mkAnn i ann) arg) args
            in
              ExprConstruct emptyAnn desc ctorArgs
      exp ->
        let
          mkAnn :: Int -> Ann -> Ann
          mkAnn = addContext <<< AppArg
        in
          ExprApp emptyAnn (transl (addContext AppFunc ann) exp) $
            mapWithIndex (\i -> transl (mkAnn i ann)) args

  translConstructor ann _ ctor args =
    let
      ctorName = mkGlobalName moduleName ctor
    in
      case Global.lookupConstructor ctorName global of
        Nothing -> unsafeCrashWith $ "translConstructor: Unknown constructor " <> show ctor
        Just desc
          | desc.arity == 0 -> ExprNone
          | otherwise ->
              let
                ctorVar = CF.ExprVar CF.emptyAnn (CF.Qualified (Just $ coerce moduleName) (coerce ctor))
                applyCtorArg term arg =
                  CF.ExprApp CF.emptyAnn term (CF.ExprVar CF.emptyAnn (CF.Qualified Nothing (coerce arg)))
                ctorVal = foldl applyCtorArg ctorVar args

              in
                transl ann (foldr (\arg term -> CF.ExprAbs CF.emptyAnn (coerce arg) term) ctorVal args)

  translExprLet ann binds expr = case spanMap CF.nonRecBinding binds of
    [] /\ rest
      | Just { head: CF.Rec bindGrp, tail } <- Array.uncons rest ->
          let
            body =
              if (Array.null tail) then expr
              else CF.ExprLet CF.emptyAnn tail expr
            trBinds = translLetBind ann <$> bindGrp
          in
            ExprLetRec ann trBinds (transl ann body)
    nonRecs /\ rest ->
      let
        body =
          if (Array.null rest) then expr
          else CF.ExprLet CF.emptyAnn rest expr
        trBinds = translLetBind ann <$> nonRecs
      in
        ExprLet ann trBinds (transl ann body)
    where
    translLetBind ann' (CF.Binding _ id b) = Tuple (coerce id) (transl ann' b)

  translExprCase ann caseExprs caseAlts =
    ExprCase
      emptyAnn
      (transl ann <$> caseExprs)
      (translCaseAlternative ann <$> caseAlts)

  translCaseAlternative ann (CF.CaseAlternative binders caseGuard) =
    let
      patterns = translCaseBinder <$> binders
      action = translCaseGuard ann caseGuard
    in
      CaseAlternative { patterns, action }

  translCaseBinder :: CF.Binder CF.Ann -> Pattern
  translCaseBinder = case _ of
    CF.BinderNull _ -> PatWildcard
    CF.BinderVar _ var -> PatVar (coerce var)
    CF.BinderLit _ lit
      | Just atomLit <- binderLiteral lit -> PatLiteral atomLit
      | otherwise -> case lit of
          CF.LitArray binders -> PatArray (translCaseBinder <$> binders)
          CF.LitRecord props -> PatRecord (map (map translCaseBinder <<< translProp) props)
          _ -> unsafeCrashWith "translCaseBinder: Impossible!"
    CF.BinderConstructor a _ ctor binders
      | CF.Ann { meta: Just CF.IsNewtype } <- a
      , Just binder <- Array.head binders -> translCaseBinder binder
      | CF.Qualified (Just (CF.ModuleName mn)) (CF.Ident ident') <- ctor
      , ctorName <- mkGlobalName (ModuleName mn) (Ident ident')
      , Just desc <- lookupConstructor ctorName global ->
          PatConstruct desc (translCaseBinder <$> binders)
      | otherwise -> unsafeCrashWith $ "Unknown constructor: " <> show ctor
    CF.BinderNamed _ ident' binder -> PatAliase (coerce ident') (translCaseBinder binder)

  translCaseGuard ann = case _ of
    CF.Unconditional expr -> transl ann expr
    -- We desugar guard case to nested if-then-else. 
    CF.Guarded guards ->
      let
        addIf (CF.Guard cond expr) = ExprIf ann (transl ann cond) (transl ann expr)
      in
        foldr addIf (ExprStaticFail ann) guards

  -- _ -> unsafeCrashWith "translCaseBinder: Impossible!"

  binderLiteral :: CF.Literal (CF.Binder _) -> Maybe AtomicConstant
  binderLiteral = case _ of
    CF.LitInt i -> Just $ ACInt i
    CF.LitBoolean b -> Just $ ACBool b
    CF.LitChar c -> Just $ ACChar c
    CF.LitNumber n -> Just $ ACNumber n
    CF.LitString s -> Just $ ACString s
    _ -> Nothing

-- CF.LitArray lits -> ExprLit unit $ LitStruct (LitArray $ map translateExpr lits)

globalNameOfExprVar :: forall a. CF.Expr a -> Maybe GlobalName
globalNameOfExprVar = case _ of
  CF.ExprVar _ (CF.Qualified (Just (CF.ModuleName mn)) (CF.Ident id)) ->
    Just $ mkGlobalName (coerce mn) (coerce id)
  _ -> Nothing

exprConstantLiteral :: GlobalEnv -> CF.Expr CF.Ann -> Maybe Literal
exprConstantLiteral _ {-genv-} = go
  where
  go = case _ of
    CF.ExprLit _ lit -> case lit of
      CF.LitInt i -> Just (LitAtomic (ACInt i))
      CF.LitChar c -> Just (LitAtomic (ACChar c))
      CF.LitBoolean b -> Just (LitAtomic (ACBool b))
      CF.LitNumber n -> Just (LitAtomic (ACNumber n))
      CF.LitString s -> Just (LitAtomic (ACString s))
      CF.LitArray lits -> LitStruct <<< LitArray <$> traverse go lits
      CF.LitRecord _ -> Nothing
    _ -> Nothing

translModuleName :: CF.ModuleName -> ModuleName
translModuleName = coerce

translProp :: CF.Prop ~> Prop
translProp (CF.Prop k v) = Prop k v

translIdent :: CF.Ident -> Ident
translIdent = coerce

spanMap :: forall a b. (a -> Maybe b) -> Array a -> Array b /\ Array a
spanMap pred xs = ST.run do
  init <- STArray.new
  rest <- STArray.thaw xs
  continue <- STRef.new true
  ST.while (STRef.read continue) do
    STArray.shift rest >>= case _ of
      Nothing -> STRef.write false continue $> unit
      Just r
        | Just b <- pred r -> STArray.push b init $> unit
        | otherwise -> STArray.unshift r rest *> STRef.write false continue $> unit
  (/\) <$> STArray.freeze init <*> STArray.freeze rest
